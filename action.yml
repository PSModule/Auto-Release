name: Auto-Release (by PSModule)
description: Automatically creates releases based on pull requests and labels.

branding:
  icon: activity
  color: blue

inputs:
  AutoPatching:
    description: Control wether to automatically handle patches. If disabled, the action will only create a patch release if the pull request has a 'patch' label.
    required: false
    default: 'true'
  IncrementalPrerelease:
    description: Control wether to automatically increment the prerelease number. If disabled, the action will ensure only one prerelease exists for a given branch.
    required: false
    default: 'true'
  VersionPrefix:
    description: The prefix to use for the version number.
    required: false
    default: 'v'

runs:
  using: composite
  steps:
    - name: Auto-Release
      shell: pwsh
      env:
        GITHUB_CONTEXT: ${{ toJson(github) }}
        JOB_CONTEXT: ${{ toJson(job) }}
        RUNNER_CONTEXT: ${{ toJson(runner) }}
        AutoPatching: ${{ inputs.AutoPatching }}
        IncrementalPrerelease: ${{ inputs.IncrementalPrerelease }}
        VersionPrefix: ${{ inputs.VersionPrefix }}
      run: |
        # Auto-Release
        Write-Host "::group::Utilities"
        Install-PSResource -Name Utilities -TrustRepository
        Write-Host "-------------------------------------------------"
        Get-PSResource -Name Utilities | Format-Table
        Write-Host "-------------------------------------------------"
        Write-Host "Get commands"
        Get-Command -Module Utilities | Format-Table
        Write-Host "-------------------------------------------------"
        Write-Host "Get aliases"
        Get-Alias | Where-Object Source -eq 'Utilities' | Format-Table
        Write-Host "-------------------------------------------------"
        Write-Host '::endgroup::'

        Write-Host "::group::Environment variables"
        Get-ChildItem -Path Env: | Select-Object Name, Value | Sort-Object Name | Format-Table -AutoSize
        Write-Host '::endgroup::'

        Write-Host "::group::GitHub context"
        Write-Host $env:GITHUB_CONTEXT
        Write-Host '::endgroup::'

        Write-Host "::group::Job context"
        Write-Host $env:JOB_CONTEXT
        Write-Host '::endgroup::'

        Write-Host "::group::Runner context"
        Write-Host $env:RUNNER_CONTEXT
        Write-Host '::endgroup::'

        $autoPatching = $env:AutoPatching -eq 'true'
        $incrementalPrerelease = $env:IncrementalPrerelease -eq 'true'
        $versionPrefix = $env:VersionPrefix
        Write-Host "-------------------------------------------------"
        Write-Host "Auto patching enabled:          [$autoPatching]"
        Write-Host "Incremental prerelease enabled: [$autoPatching]"
        Write-Host "Version prefix:                 [$versionPrefix]"
        Write-Host "-------------------------------------------------"

        $githubEventJson = Get-Content $env:GITHUB_EVENT_PATH
        $githubEvent = $githubEventJson | ConvertFrom-Json
        $pull_request = $githubEvent.pull_request

        Write-Host "::group::Event information - JSON"
        $githubEventJson | Format-List
        Write-Host '::endgroup::'

        Write-Host "::group::Event information - Object"
        $githubEvent | Format-List
        Write-Host '::endgroup::'

        $isPullRequest = $githubEvent.PSObject.Properties.Name -Contains 'pull_request'
        if (-not $isPullRequest) {
          "A release should not be created in this context. Exiting."
          return
        }
        Write-Host "-------------------------------------------------"
        Write-Host "Is a pull request event:        [$isPullRequest]"
        Write-Host "Action type:                    [$($githubEvent.action)]"
        Write-Host "PR Merged:                      [$($pull_request.merged)]"
        Write-Host "PR State:                       [$($pull_request.state)]"
        Write-Host "PR Base Ref:                    [$($pull_request.base.ref)]"
        Write-Host "PR Head Ref:                    [$($pull_request.head.ref)]"
        Write-Host "-------------------------------------------------"
        $preReleaseName = $pull_request.head.ref -replace '[^a-zA-Z0-9]', ''

        Write-Host "::group::Pull request - details"
        $pull_request | Format-List
        Write-Host '::endgroup::'

        Write-Host '::group::Pull request - Labels'
        $labels = @()
        $labels += $pull_request.labels.name
        $labels | Format-List
        $majorRelease = $labels -Contains 'major' -or $labels -Contains 'breaking'
        $minorRelease = $labels -Contains 'minor' -or $labels -Contains 'feature' -or $labels -Contains 'improvement'
        $patchRelease = $labels -Contains 'patch' -or $labels -Contains 'fix' -or $labels -Contains 'bug'
        $preRelease = $labels -Contains 'prerelease'
        Write-Host '::endgroup::'

        Write-Host "-------------------------------------------------"
        Write-Host "Is a major release:             [$majorRelease]"
        Write-Host "Is a minor release:             [$minorRelease]"
        Write-Host "Is a patch release:             [$patchRelease]"
        Write-Host "Is a prerelease:                [$preRelease]"
        Write-Host "-------------------------------------------------"

        $mergedToMain = $pull_request.base.ref -eq 'main' -and $pull_request.merged -eq 'True'

        # Skip out if not a merge to main or a prerelease
        if (-not ($preRelease -or $mergedToMain)) {
            Write-Host "Skipping release creation, exiting."
            return
        }
        if ($mergedToMain) {
            $preRelease = $false
        }

        Write-Host '::group::Get releases'
        $releases = gh release list --json createdAt,isDraft,isLatest,isPrerelease,name,publishedAt,tagName | ConvertFrom-Json
        $releases | Format-List
        Write-Host '::endgroup::'

        Write-Host '::group::Get latest version'
        $latestRelease = $releases | Where-Object { $_.isLatest -eq $true }
        $latestRelease | Format-List
        $latestVersionString = $latestRelease.tagName
        if ($latestVersionString | IsNotNullOrEmpty) {
            $latestVersion = $latestVersionString | ConvertTo-SemVer
            Write-Host "-------------------------------------------------"
            Write-Host 'Latest version:'
            $latestVersion | Format-Table
            $latestVersion = "{0}{1}.{2}.{3}" -f $versionPrefix, $latestVersion.Major, $latestVersion.Minor, $latestVersion.Patch
        }
        Write-Host '::endgroup::'

        Write-Host "-------------------------------------------------"
        Write-Host "Latest version:                 [$latestVersion]"
        Write-Host "-------------------------------------------------"

        Write-Host '::group::Calculate new version'
        $version = $latestVersion | ConvertTo-SemVer
        $major = $version.Major
        $minor = $version.Minor
        $patch = $version.Patch
        if ($majorRelease) {
            Write-Host 'Incrementing major version.'
            $major++
            $minor = 0
            $patch = 0
        } elseif ($minorRelease) {
            Write-Host 'Incrementing minor version.'
            $minor++
            $patch = 0
        } elseif ($patchRelease -or $autoPatching) {
            Write-Host 'Incrementing patch version.'
            $patch++
        } else {
            Write-Host 'Skipping release creation, exiting.'
            return
        }

        $newVersion = "{0}{1}.{2}.{3}" -f $versionPrefix, $major, $minor, $patch
        Write-Host "Partly new version: [$newVersion]"

        if ($preRelease) {
          Write-Host "Adding a prerelease tag to the version using the branch name [$preReleaseName]."
          $newVersion = "$newVersion-$preReleaseName"
          Write-Host "Partly new version: [$newVersion]"

          if ($incrementalPrerelease) {
            $prereleases = $releases | Where-Object { $_.tagName -like "$newVersion*" } | Sort-Object -Descending -Property tagName
            Write-Host "Prereleases:                    [$($prereleases.count)]"
            if ($prereleases.count -gt 0) {
              $latestPrereleaseVersion = ($prereleases[0].tagName | ConvertTo-SemVer) | Select-Object -ExpandProperty Prerelease
              Write-Host "Latest prerelease:              [$latestPrereleaseVersion]"
              $latestPrereleaseNumber = [int]($latestPrereleaseVersion -Split '\.')[-1]
              Write-Host "Latest prerelease number:       [$latestPrereleaseNumber]"
            }

            $newPrereleaseNumber = 0 + $latestPrereleaseNumber + 1
            $newVersion = $newVersion + "." + $newPrereleaseNumber
          }
        }
        Write-Host '::endgroup::'
        Write-Host "-------------------------------------------------"
        Write-Host "New version:                    [$newVersion]"
        Write-Host "-------------------------------------------------"

        Write-Host "::group::Create new release [$newVersion]"
        if ($preRelease) {
          $releaseExists = $releases.tagName -Contains $newVersion
          if ($releaseExists -and -not $incrementalPrerelease) {
            Write-Host "Release already exists, recreating."
            gh release delete $newVersion --cleanup-tag --yes
            if ($LASTEXITCODE -ne 0) {
              Write-Error "Failed to delete the release [$newVersion]."
              exit $LASTEXITCODE
            }
          }

          gh release create $newVersion --title $newVersion --generate-notes --prerelease
          if ($LASTEXITCODE -ne 0) {
            Write-Error "Failed to create the release [$newVersion]."
            exit $LASTEXITCODE
          }
          return
        }

        gh release create $newVersion --title $newVersion --generate-notes
        git tag -f ("{0}{1}" -f $versionPrefix, $major) 'main'
        git tag -f ("{0}{1}.{2}" -f $versionPrefix, $major, $minor) 'main'
        git push origin --tags --force
        if ($LASTEXITCODE -ne 0) {
          Write-Error "Failed to create the release [$newVersion]."
          exit $LASTEXITCODE
        }
        Write-Host '::endgroup::'

        Write-Host "::group::Cleanup prereleases for [$preReleaseName]"
        $prereleasesToCleanup = $releases | Where-Object { $_.tagName -like "*$preReleaseName*" }
        foreach ($rel in $prereleasesToCleanup) {
          Write-Host "Deleting prerelease:            [$($rel.tagName)]."
          gh release delete $rel.tagName --cleanup-tag --yes
        }
        Write-Host '::endgroup::'
